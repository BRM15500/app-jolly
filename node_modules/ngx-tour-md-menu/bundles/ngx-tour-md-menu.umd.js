(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/core'), require('ngx-tour-core'), require('@angular/material'), require('withinviewport'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-tour-md-menu', ['exports', 'tslib', '@angular/core', 'ngx-tour-core', '@angular/material', 'withinviewport', 'rxjs/operators', '@angular/common'], factory) :
    (factory((global['ngx-tour-md-menu'] = {}),global.tslib,global.ng.core,null,global.ng.material,null,global.Rx.Observable.prototype,global.ng.common));
}(this, (function (exports,tslib_1,core,ngxTourCore,material,withinviewport,operators,common) { 'use strict';

    withinviewport = withinviewport && withinviewport.hasOwnProperty('default') ? withinviewport['default'] : withinviewport;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NgxmTourService = (function (_super) {
        tslib_1.__extends(NgxmTourService, _super);
        function NgxmTourService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NgxmTourService.decorators = [
            { type: core.Injectable },
        ];
        return NgxmTourService;
    }(ngxTourCore.TourService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TourAnchorOpenerComponent = (function () {
        function TourAnchorOpenerComponent() {
            this.menu = new material.MatMenu(undefined, undefined, { xPosition: 'after', yPosition: 'below', overlapTrigger: true, backdropClass: '' });
        }
        TourAnchorOpenerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tourAnchorOpener',
                        styles: [":host { display: none; }"],
                        template: "<span [matMenuTriggerFor]=\"menu\" #trigger=\"matMenuTrigger\"></span>"
                    },] },
        ];
        /** @nocollapse */
        TourAnchorOpenerComponent.propDecorators = {
            "menu": [{ type: core.Input },],
            "trigger": [{ type: core.ViewChild, args: [material.MatMenuTrigger,] },],
        };
        return TourAnchorOpenerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TourStepTemplateService = (function () {
        function TourStepTemplateService() {
        }
        TourStepTemplateService.decorators = [
            { type: core.Injectable },
        ];
        return TourStepTemplateService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TourBackdropService = (function () {
        function TourBackdropService(rendererFactory) {
            this.renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * @param {?} targetElement
         * @return {?}
         */
        TourBackdropService.prototype.show = /**
         * @param {?} targetElement
         * @return {?}
         */
            function (targetElement) {
                var /** @type {?} */ boundingRect = targetElement.nativeElement.getBoundingClientRect();
                if (!this.backdropElement) {
                    this.backdropElement = this.renderer.createElement('div');
                    this.renderer.addClass(this.backdropElement, 'ngx-tour_backdrop');
                    this.renderer.appendChild(document.body, this.backdropElement);
                }
                this.setStyles(boundingRect);
            };
        /**
         * @return {?}
         */
        TourBackdropService.prototype.close = /**
         * @return {?}
         */
            function () {
                if (this.backdropElement) {
                    this.renderer.removeChild(document.body, this.backdropElement);
                    this.backdropElement = null;
                }
            };
        /**
         * @param {?} boundingRect
         * @return {?}
         */
        TourBackdropService.prototype.setStyles = /**
         * @param {?} boundingRect
         * @return {?}
         */
            function (boundingRect) {
                var /** @type {?} */ styles = {
                    position: 'fixed',
                    width: boundingRect.width + 'px',
                    height: boundingRect.height + 'px',
                    top: boundingRect.top + 'px',
                    left: boundingRect.left + 'px',
                    'box-shadow': '0 0 0 9999px rgba(0, 0, 0, 0.7)',
                    'z-index': '100'
                };
                try {
                    for (var _a = tslib_1.__values(Object.keys(styles)), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var name_1 = _b.value;
                        this.renderer.setStyle(this.backdropElement, name_1, styles[name_1]);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                var e_1, _c;
            };
        TourBackdropService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TourBackdropService.ctorParameters = function () {
            return [
                { type: core.RendererFactory2, },
            ];
        };
        return TourBackdropService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TourAnchorMatMenuDirective = (function () {
        function TourAnchorMatMenuDirective(componentFactoryResolver, injector, viewContainer, element, tourService, tourStepTemplate, tourBackdrop) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.injector = injector;
            this.viewContainer = viewContainer;
            this.element = element;
            this.tourService = tourService;
            this.tourStepTemplate = tourStepTemplate;
            this.tourBackdrop = tourBackdrop;
            this.opener = this.viewContainer.createComponent(this.componentFactoryResolver.resolveComponentFactory(TourAnchorOpenerComponent)).instance;
        }
        /**
         * @return {?}
         */
        TourAnchorMatMenuDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.tourService.register(this.tourAnchor, this);
            };
        /**
         * @return {?}
         */
        TourAnchorMatMenuDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.tourService.unregister(this.tourAnchor);
            };
        /**
         * @param {?} step
         * @return {?}
         */
        TourAnchorMatMenuDirective.prototype.showTourStep = /**
         * @param {?} step
         * @return {?}
         */
            function (step) {
                var _this = this;
                this.isActive = true;
                this.tourStepTemplate.templateComponent.step = step;
                // Ignore step.placement
                if (!step.preventScrolling) {
                    if (!withinviewport(this.element.nativeElement, { sides: 'bottom' })) {
                        ((this.element.nativeElement)).scrollIntoView(false);
                    }
                    else if (!withinviewport(this.element.nativeElement, { sides: 'left top right' })) {
                        ((this.element.nativeElement)).scrollIntoView(true);
                    }
                }
                ((this.opener.trigger))._element = this.element;
                this.opener.trigger.menu = this.tourStepTemplate.templateComponent.tourStep;
                this.opener.trigger.ngAfterContentInit();
                this.opener.trigger.openMenu();
                if (step.enableBackdrop) {
                    this.tourBackdrop.show(this.element);
                }
                else {
                    this.tourBackdrop.close();
                }
                step.prevBtnTitle = step.prevBtnTitle || 'Prev';
                step.nextBtnTitle = step.nextBtnTitle || 'Next';
                step.endBtnTitle = step.endBtnTitle || 'End';
                if (this.menuCloseSubscription) {
                    this.menuCloseSubscription.unsubscribe();
                }
                this.menuCloseSubscription = this.opener.trigger.menuClosed
                    .pipe(operators.first())
                    .subscribe(function () {
                    if (_this.tourService.getStatus() !== ngxTourCore.TourState.OFF) {
                        _this.tourService.end();
                    }
                    _this.tourBackdrop.close();
                });
            };
        /**
         * @return {?}
         */
        TourAnchorMatMenuDirective.prototype.hideTourStep = /**
         * @return {?}
         */
            function () {
                this.isActive = false;
                if (this.menuCloseSubscription) {
                    this.menuCloseSubscription.unsubscribe();
                }
                this.opener.trigger.closeMenu();
                if (this.tourService.getStatus() === ngxTourCore.TourState.OFF) {
                    this.tourBackdrop.close();
                }
            };
        TourAnchorMatMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[tourAnchor]'
                    },] },
        ];
        /** @nocollapse */
        TourAnchorMatMenuDirective.ctorParameters = function () {
            return [
                { type: core.ComponentFactoryResolver, },
                { type: core.Injector, },
                { type: core.ViewContainerRef, },
                { type: core.ElementRef, },
                { type: NgxmTourService, },
                { type: TourStepTemplateService, },
                { type: TourBackdropService, },
            ];
        };
        TourAnchorMatMenuDirective.propDecorators = {
            "tourAnchor": [{ type: core.Input },],
            "isActive": [{ type: core.HostBinding, args: ['class.touranchor--is-active',] },],
        };
        return TourAnchorMatMenuDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TourStepTemplateComponent = (function (_super) {
        tslib_1.__extends(TourStepTemplateComponent, _super);
        function TourStepTemplateComponent(tourStepTemplateService, tourService) {
            var _this = _super.call(this, tourService) || this;
            _this.tourStepTemplateService = tourStepTemplateService;
            _this.tourService = tourService;
            _this.step = {};
            return _this;
        }
        /**
         * @return {?}
         */
        TourStepTemplateComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.tourStepTemplateService.templateComponent = this;
            };
        TourStepTemplateComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tour-step-template',
                        styles: ["\n      ::ng-deep .tour-step .mat-menu-content { \n          padding: 0 !important; \n      }\n  "],
                        template: "\n    <mat-menu [overlapTrigger]=\"false\" class=\"tour-step\">\n      <ng-container *ngTemplateOutlet=\"stepTemplate || defaultTemplate; context: { step: step }\"></ng-container>\n    </mat-menu>\n    <ng-template #defaultTemplate let-step=\"step\">\n      <mat-card (click)=\"$event.stopPropagation()\">\n        <mat-card-title>\n          {{step?.title}}\n        </mat-card-title>\n        <mat-card-content>\n          {{step?.content}}\n        </mat-card-content>\n        <mat-card-actions>\n          <button mat-icon-button [disabled]=\"!tourService.hasPrev(step)\" (click)=\"tourService.prev()\">\n            <mat-icon>chevron_left</mat-icon>\n          </button>\n          <button mat-icon-button [disabled]=\"!tourService.hasNext(step)\" (click)=\"tourService.next()\">\n            <mat-icon>chevron_right</mat-icon>\n          </button>\n          <button mat-button (click)=\"tourService.end()\">{{step?.endBtnTitle}}</button>\n        </mat-card-actions>\n      </mat-card>\n    </ng-template>\n  ",
                    },] },
        ];
        /** @nocollapse */
        TourStepTemplateComponent.ctorParameters = function () {
            return [
                { type: TourStepTemplateService, },
                { type: NgxmTourService, },
            ];
        };
        TourStepTemplateComponent.propDecorators = {
            "tourStep": [{ type: core.ViewChild, args: [material.MatMenu,] },],
            "stepTemplate": [{ type: core.Input }, { type: core.ContentChild, args: [core.TemplateRef,] },],
        };
        return TourStepTemplateComponent;
    }(ngxTourCore.TourHotkeyListenerComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TourMatMenuModule = (function () {
        function TourMatMenuModule() {
        }
        /**
         * @return {?}
         */
        TourMatMenuModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: TourMatMenuModule,
                    providers: tslib_1.__spread([
                        TourStepTemplateService,
                        TourBackdropService
                    ], ngxTourCore.TourModule.forRoot().providers, [
                        NgxmTourService
                    ]),
                };
            };
        TourMatMenuModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [TourAnchorMatMenuDirective, TourStepTemplateComponent, TourAnchorOpenerComponent],
                        entryComponents: [TourAnchorOpenerComponent],
                        exports: [TourAnchorMatMenuDirective, TourStepTemplateComponent, ngxTourCore.TourModule],
                        imports: [common.CommonModule, ngxTourCore.TourModule,
                            material.MatMenuModule, material.MatCardModule, material.MatButtonModule, material.MatIconModule,
                        ],
                    },] },
        ];
        return TourMatMenuModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.TourService = NgxmTourService;
    exports.TourMatMenuModule = TourMatMenuModule;
    exports.TourAnchorMatMenuDirective = TourAnchorMatMenuDirective;
    exports.TourStepTemplateComponent = TourStepTemplateComponent;
    exports.ɵa = NgxmTourService;
    exports.ɵd = TourAnchorOpenerComponent;
    exports.ɵc = TourBackdropService;
    exports.ɵb = TourStepTemplateService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXRvdXItbWQtbWVudS51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL25neC10b3VyLW1kLW1lbnUvbGliL25neC1tZC1tZW51LXRvdXIuc2VydmljZS50cyIsIm5nOi8vbmd4LXRvdXItbWQtbWVudS9saWIvdG91ci1hbmNob3Itb3BlbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LXRvdXItbWQtbWVudS9saWIvdG91ci1zdGVwLXRlbXBsYXRlLnNlcnZpY2UudHMiLCJuZzovL25neC10b3VyLW1kLW1lbnUvbGliL3RvdXItYmFja2Ryb3Auc2VydmljZS50cyIsIm5nOi8vbmd4LXRvdXItbWQtbWVudS9saWIvdG91ci1hbmNob3IuZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtdG91ci1tZC1tZW51L2xpYi90b3VyLXN0ZXAtdGVtcGxhdGUuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtdG91ci1tZC1tZW51L2xpYi9tZC1tZW51Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUb3VyU2VydmljZSB9IGZyb20gJ25neC10b3VyLWNvcmUnO1xuXG5pbXBvcnQgeyBJTmd4bVN0ZXBPcHRpb24gfSBmcm9tICcuL3N0ZXAtb3B0aW9uLmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3htVG91clNlcnZpY2UgZXh0ZW5kcyBUb3VyU2VydmljZTxJTmd4bVN0ZXBPcHRpb24+IHt9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIFZpZXdDaGlsZCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdE1lbnVUcmlnZ2VyLCBNYXRNZW51IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd0b3VyQW5jaG9yT3BlbmVyJyxcbiAgc3R5bGVzOiBbYDpob3N0IHsgZGlzcGxheTogbm9uZTsgfWBdLFxuICB0ZW1wbGF0ZTogYDxzcGFuIFttYXRNZW51VHJpZ2dlckZvcl09XCJtZW51XCIgI3RyaWdnZXI9XCJtYXRNZW51VHJpZ2dlclwiPjwvc3Bhbj5gXG59KVxuZXhwb3J0IGNsYXNzIFRvdXJBbmNob3JPcGVuZXJDb21wb25lbnQge1xuICBASW5wdXQoKSBtZW51OiBNYXRNZW51ID0gbmV3IE1hdE1lbnUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgeFBvc2l0aW9uOiAnYWZ0ZXInLCB5UG9zaXRpb246ICdiZWxvdycsIG92ZXJsYXBUcmlnZ2VyOiB0cnVlLCBiYWNrZHJvcENsYXNzOiAnJyB9KTtcblxuICBAVmlld0NoaWxkKE1hdE1lbnVUcmlnZ2VyKSBwdWJsaWMgdHJpZ2dlcjogTWF0TWVudVRyaWdnZXI7XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFRvdXJTdGVwVGVtcGxhdGVDb21wb25lbnQgfSBmcm9tICcuL3RvdXItc3RlcC10ZW1wbGF0ZS5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVG91clN0ZXBUZW1wbGF0ZVNlcnZpY2Uge1xuICBwdWJsaWMgdGVtcGxhdGVDb21wb25lbnQ6IFRvdXJTdGVwVGVtcGxhdGVDb21wb25lbnQ7XG59XG4iLCJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RhYmxlLCBSZW5kZXJlcjIsIFJlbmRlcmVyRmFjdG9yeTIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRvdXJCYWNrZHJvcFNlcnZpY2Uge1xuICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjI7XG4gIHByaXZhdGUgYmFja2Ryb3BFbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICBjb25zdHJ1Y3RvcihyZW5kZXJlckZhY3Rvcnk6IFJlbmRlcmVyRmFjdG9yeTIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xuICB9XG5cbiAgcHVibGljIHNob3codGFyZ2V0RWxlbWVudDogRWxlbWVudFJlZikge1xuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IHRhcmdldEVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmICghdGhpcy5iYWNrZHJvcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuYmFja2Ryb3BFbGVtZW50ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5iYWNrZHJvcEVsZW1lbnQsICduZ3gtdG91cl9iYWNrZHJvcCcpO1xuICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLmJhY2tkcm9wRWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdHlsZXMoYm91bmRpbmdSZWN0KTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5iYWNrZHJvcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5iYWNrZHJvcEVsZW1lbnQpO1xuICAgICAgdGhpcy5iYWNrZHJvcEVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0U3R5bGVzKGJvdW5kaW5nUmVjdDogRE9NUmVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCArICdweCcsXG4gICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQgKyAncHgnLFxuICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wICsgJ3B4JyxcbiAgICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0ICsgJ3B4JyxcbiAgICAgICdib3gtc2hhZG93JzogJzAgMCAwIDk5OTlweCByZ2JhKDAsIDAsIDAsIDAuNyknLFxuICAgICAgJ3otaW5kZXgnOiAnMTAwJ1xuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoc3R5bGVzKSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmJhY2tkcm9wRWxlbWVudCwgbmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIFRvdXJBbmNob3JEaXJlY3RpdmUsXG4gIFRvdXJTdGF0ZVxufSBmcm9tICduZ3gtdG91ci1jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHdpdGhpbnZpZXdwb3J0IGZyb20gJ3dpdGhpbnZpZXdwb3J0JztcblxuaW1wb3J0IHsgVG91ckFuY2hvck9wZW5lckNvbXBvbmVudCB9IGZyb20gJy4vdG91ci1hbmNob3Itb3BlbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb3VyU3RlcFRlbXBsYXRlU2VydmljZSB9IGZyb20gJy4vdG91ci1zdGVwLXRlbXBsYXRlLnNlcnZpY2UnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1RvdXJCYWNrZHJvcFNlcnZpY2V9IGZyb20gJy4vdG91ci1iYWNrZHJvcC5zZXJ2aWNlJztcbmltcG9ydCB7IElOZ3htU3RlcE9wdGlvbiBhcyBJU3RlcE9wdGlvbiB9IGZyb20gJy4vc3RlcC1vcHRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7Tmd4bVRvdXJTZXJ2aWNlfSBmcm9tICcuL25neC1tZC1tZW51LXRvdXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t0b3VyQW5jaG9yXSdcbn0pXG5leHBvcnQgY2xhc3MgVG91ckFuY2hvck1hdE1lbnVEaXJlY3RpdmVcbiAgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgVG91ckFuY2hvckRpcmVjdGl2ZSB7XG4gIEBJbnB1dCgpIHB1YmxpYyB0b3VyQW5jaG9yOiBzdHJpbmc7XG4gIHB1YmxpYyBvcGVuZXI6IFRvdXJBbmNob3JPcGVuZXJDb21wb25lbnQ7XG4gIHB1YmxpYyBtZW51Q2xvc2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnRvdXJhbmNob3ItLWlzLWFjdGl2ZScpIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSB0b3VyU2VydmljZTogTmd4bVRvdXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgdG91clN0ZXBUZW1wbGF0ZTogVG91clN0ZXBUZW1wbGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSB0b3VyQmFja2Ryb3A6IFRvdXJCYWNrZHJvcFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5vcGVuZXIgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KFxuICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoXG4gICAgICAgIFRvdXJBbmNob3JPcGVuZXJDb21wb25lbnRcbiAgICAgIClcbiAgICApLmluc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMudG91clNlcnZpY2UucmVnaXN0ZXIodGhpcy50b3VyQW5jaG9yLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnRvdXJTZXJ2aWNlLnVucmVnaXN0ZXIodGhpcy50b3VyQW5jaG9yKTtcbiAgfVxuXG4gIHB1YmxpYyBzaG93VG91clN0ZXAoc3RlcDogSVN0ZXBPcHRpb24pOiB2b2lkIHtcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnRvdXJTdGVwVGVtcGxhdGUudGVtcGxhdGVDb21wb25lbnQuc3RlcCA9IHN0ZXA7XG4gICAgLy8gSWdub3JlIHN0ZXAucGxhY2VtZW50XG4gICAgaWYgKCFzdGVwLnByZXZlbnRTY3JvbGxpbmcpIHtcbiAgICAgIGlmICghd2l0aGludmlld3BvcnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHsgc2lkZXM6ICdib3R0b20nIH0pKSB7XG4gICAgICAgICg8SFRNTEVsZW1lbnQ+dGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpLnNjcm9sbEludG9WaWV3KGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICF3aXRoaW52aWV3cG9ydCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgeyBzaWRlczogJ2xlZnQgdG9wIHJpZ2h0JyB9KVxuICAgICAgKSB7XG4gICAgICAgICg8SFRNTEVsZW1lbnQ+dGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpLnNjcm9sbEludG9WaWV3KHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAoPGFueT50aGlzLm9wZW5lci50cmlnZ2VyKS5fZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLm9wZW5lci50cmlnZ2VyLm1lbnUgPSB0aGlzLnRvdXJTdGVwVGVtcGxhdGUudGVtcGxhdGVDb21wb25lbnQudG91clN0ZXA7XG4gICAgdGhpcy5vcGVuZXIudHJpZ2dlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICB0aGlzLm9wZW5lci50cmlnZ2VyLm9wZW5NZW51KCk7XG5cbiAgICBpZiAoc3RlcC5lbmFibGVCYWNrZHJvcCkge1xuICAgICAgdGhpcy50b3VyQmFja2Ryb3Auc2hvdyh0aGlzLmVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvdXJCYWNrZHJvcC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHN0ZXAucHJldkJ0blRpdGxlID0gc3RlcC5wcmV2QnRuVGl0bGUgfHwgJ1ByZXYnO1xuICAgIHN0ZXAubmV4dEJ0blRpdGxlID0gc3RlcC5uZXh0QnRuVGl0bGUgfHwgJ05leHQnO1xuICAgIHN0ZXAuZW5kQnRuVGl0bGUgPSBzdGVwLmVuZEJ0blRpdGxlIHx8ICdFbmQnO1xuXG4gICAgaWYgKHRoaXMubWVudUNsb3NlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLm1lbnVDbG9zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0aGlzLm1lbnVDbG9zZVN1YnNjcmlwdGlvbiA9IHRoaXMub3BlbmVyLnRyaWdnZXIubWVudUNsb3NlZFxuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy50b3VyU2VydmljZS5nZXRTdGF0dXMoKSAhPT0gVG91clN0YXRlLk9GRikge1xuICAgICAgICAgIHRoaXMudG91clNlcnZpY2UuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VyQmFja2Ryb3AuY2xvc2UoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGhpZGVUb3VyU3RlcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubWVudUNsb3NlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLm1lbnVDbG9zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5lci50cmlnZ2VyLmNsb3NlTWVudSgpO1xuICAgIGlmICh0aGlzLnRvdXJTZXJ2aWNlLmdldFN0YXR1cygpID09PSBUb3VyU3RhdGUuT0ZGKSB7XG4gICAgICB0aGlzLnRvdXJCYWNrZHJvcC5jbG9zZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRNZW51IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgSVN0ZXBPcHRpb24sIFRvdXJIb3RrZXlMaXN0ZW5lckNvbXBvbmVudCB9IGZyb20gJ25neC10b3VyLWNvcmUnO1xuXG5pbXBvcnQgeyBUb3VyU3RlcFRlbXBsYXRlU2VydmljZSB9IGZyb20gJy4vdG91ci1zdGVwLXRlbXBsYXRlLnNlcnZpY2UnO1xuaW1wb3J0IHtOZ3htVG91clNlcnZpY2V9IGZyb20gJy4vbmd4LW1kLW1lbnUtdG91ci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndG91ci1zdGVwLXRlbXBsYXRlJyxcbiAgc3R5bGVzOiBbYFxuICAgICAgOjpuZy1kZWVwIC50b3VyLXN0ZXAgLm1hdC1tZW51LWNvbnRlbnQgeyBcbiAgICAgICAgICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7IFxuICAgICAgfVxuICBgXSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bWF0LW1lbnUgW292ZXJsYXBUcmlnZ2VyXT1cImZhbHNlXCIgY2xhc3M9XCJ0b3VyLXN0ZXBcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdGVwVGVtcGxhdGUgfHwgZGVmYXVsdFRlbXBsYXRlOyBjb250ZXh0OiB7IHN0ZXA6IHN0ZXAgfVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbWF0LW1lbnU+XG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0VGVtcGxhdGUgbGV0LXN0ZXA9XCJzdGVwXCI+XG4gICAgICA8bWF0LWNhcmQgKGNsaWNrKT1cIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiPlxuICAgICAgICA8bWF0LWNhcmQtdGl0bGU+XG4gICAgICAgICAge3tzdGVwPy50aXRsZX19XG4gICAgICAgIDwvbWF0LWNhcmQtdGl0bGU+XG4gICAgICAgIDxtYXQtY2FyZC1jb250ZW50PlxuICAgICAgICAgIHt7c3RlcD8uY29udGVudH19XG4gICAgICAgIDwvbWF0LWNhcmQtY29udGVudD5cbiAgICAgICAgPG1hdC1jYXJkLWFjdGlvbnM+XG4gICAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gW2Rpc2FibGVkXT1cIiF0b3VyU2VydmljZS5oYXNQcmV2KHN0ZXApXCIgKGNsaWNrKT1cInRvdXJTZXJ2aWNlLnByZXYoKVwiPlxuICAgICAgICAgICAgPG1hdC1pY29uPmNoZXZyb25fbGVmdDwvbWF0LWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gW2Rpc2FibGVkXT1cIiF0b3VyU2VydmljZS5oYXNOZXh0KHN0ZXApXCIgKGNsaWNrKT1cInRvdXJTZXJ2aWNlLm5leHQoKVwiPlxuICAgICAgICAgICAgPG1hdC1pY29uPmNoZXZyb25fcmlnaHQ8L21hdC1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gbWF0LWJ1dHRvbiAoY2xpY2spPVwidG91clNlcnZpY2UuZW5kKClcIj57e3N0ZXA/LmVuZEJ0blRpdGxlfX08L2J1dHRvbj5cbiAgICAgICAgPC9tYXQtY2FyZC1hY3Rpb25zPlxuICAgICAgPC9tYXQtY2FyZD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBUb3VyU3RlcFRlbXBsYXRlQ29tcG9uZW50IGV4dGVuZHMgVG91ckhvdGtleUxpc3RlbmVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIEBWaWV3Q2hpbGQoTWF0TWVudSkgcHVibGljIHRvdXJTdGVwOiBNYXRNZW51O1xuXG4gIEBJbnB1dCgpXG4gIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYpXG4gIHB1YmxpYyBzdGVwVGVtcGxhdGU6IFRlbXBsYXRlUmVmPHsgc3RlcDogSVN0ZXBPcHRpb24gfT47XG5cbiAgcHVibGljIHN0ZXA6IElTdGVwT3B0aW9uID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0b3VyU3RlcFRlbXBsYXRlU2VydmljZTogVG91clN0ZXBUZW1wbGF0ZVNlcnZpY2UsIHB1YmxpYyB0b3VyU2VydmljZTogTmd4bVRvdXJTZXJ2aWNlKSB7XG4gICAgc3VwZXIodG91clNlcnZpY2UpO1xuICB9XG5cbiAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnRvdXJTdGVwVGVtcGxhdGVTZXJ2aWNlLnRlbXBsYXRlQ29tcG9uZW50ID0gdGhpcztcbiAgfVxufVxuIiwiaW1wb3J0IHsgVG91ckFuY2hvck9wZW5lckNvbXBvbmVudCB9IGZyb20gJy4vdG91ci1hbmNob3Itb3BlbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdE1lbnVNb2R1bGUsIE1hdEJ1dHRvbk1vZHVsZSwgTWF0Q2FyZE1vZHVsZSwgTWF0SWNvbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcblxuaW1wb3J0IHsgVG91ck1vZHVsZSB9IGZyb20gJ25neC10b3VyLWNvcmUnO1xuaW1wb3J0IHsgVG91ckFuY2hvck1hdE1lbnVEaXJlY3RpdmUgfSBmcm9tICcuL3RvdXItYW5jaG9yLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUb3VyU3RlcFRlbXBsYXRlQ29tcG9uZW50IH0gZnJvbSAnLi90b3VyLXN0ZXAtdGVtcGxhdGUuY29tcG9uZW50JztcbmltcG9ydCB7IFRvdXJTdGVwVGVtcGxhdGVTZXJ2aWNlIH0gZnJvbSAnLi90b3VyLXN0ZXAtdGVtcGxhdGUuc2VydmljZSc7XG5pbXBvcnQge1RvdXJCYWNrZHJvcFNlcnZpY2V9IGZyb20gJy4vdG91ci1iYWNrZHJvcC5zZXJ2aWNlJztcbmltcG9ydCB7Tmd4bVRvdXJTZXJ2aWNlfSBmcm9tICcuL25neC1tZC1tZW51LXRvdXIuc2VydmljZSc7XG5cbmV4cG9ydCB7IFRvdXJBbmNob3JNYXRNZW51RGlyZWN0aXZlLCBUb3VyU3RlcFRlbXBsYXRlQ29tcG9uZW50LCBOZ3htVG91clNlcnZpY2UgfTtcblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbVG91ckFuY2hvck1hdE1lbnVEaXJlY3RpdmUsIFRvdXJTdGVwVGVtcGxhdGVDb21wb25lbnQsIFRvdXJBbmNob3JPcGVuZXJDb21wb25lbnRdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtUb3VyQW5jaG9yT3BlbmVyQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW1RvdXJBbmNob3JNYXRNZW51RGlyZWN0aXZlLCBUb3VyU3RlcFRlbXBsYXRlQ29tcG9uZW50LCBUb3VyTW9kdWxlXSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgVG91ck1vZHVsZSxcbiAgICBNYXRNZW51TW9kdWxlLCBNYXRDYXJkTW9kdWxlLCBNYXRCdXR0b25Nb2R1bGUsIE1hdEljb25Nb2R1bGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRvdXJNYXRNZW51TW9kdWxlIHtcbiAgcHVibGljIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogVG91ck1hdE1lbnVNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgVG91clN0ZXBUZW1wbGF0ZVNlcnZpY2UsXG4gICAgICAgIFRvdXJCYWNrZHJvcFNlcnZpY2UsXG4gICAgICAgIC4uLlRvdXJNb2R1bGUuZm9yUm9vdCgpLnByb3ZpZGVycyxcbiAgICAgICAgICBOZ3htVG91clNlcnZpY2VcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIiwiSW5qZWN0YWJsZSIsIlRvdXJTZXJ2aWNlIiwiTWF0TWVudSIsIkNvbXBvbmVudCIsIklucHV0IiwiVmlld0NoaWxkIiwiTWF0TWVudVRyaWdnZXIiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiUmVuZGVyZXJGYWN0b3J5MiIsImZpcnN0IiwiVG91clN0YXRlIiwiRGlyZWN0aXZlIiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwiSW5qZWN0b3IiLCJWaWV3Q29udGFpbmVyUmVmIiwiRWxlbWVudFJlZiIsIkhvc3RCaW5kaW5nIiwiQ29udGVudENoaWxkIiwiVGVtcGxhdGVSZWYiLCJUb3VySG90a2V5TGlzdGVuZXJDb21wb25lbnQiLCJUb3VyTW9kdWxlIiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiLCJNYXRNZW51TW9kdWxlIiwiTWF0Q2FyZE1vZHVsZSIsIk1hdEJ1dHRvbk1vZHVsZSIsIk1hdEljb25Nb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7UUFNcUNBLDJDQUE0Qjs7Ozs7b0JBRGhFQyxlQUFVOzs4QkFMWDtNQU1xQ0MsdUJBQVc7Ozs7OztBQ05oRDs7d0JBUzJCLElBQUlDLGdCQUFPLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsQ0FBQzs7O29CQU5oSkMsY0FBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxrQkFBa0I7d0JBQzVCLE1BQU0sRUFBRSxDQUFDLDBCQUEwQixDQUFDO3dCQUNwQyxRQUFRLEVBQUUsd0VBQW9FO3FCQUMvRTs7Ozs2QkFFRUMs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